{
  "name": "Mvp-helpers",
  "tagline": "Helper classes to build Android Apps through MVP pattern in a faster way",
  "body": "#MVP Helpers\r\n\r\nAftter digging a lot of time with Apps under **MVP pattern**, I started to see classes that could be abstracted in a simpler way in order to use them to build Apps more faster.\r\nThis library is intended to provide helpers classes, I don't want to build a robust library because what I love from Android, is the ability to use the patterns you want to create a determinated set of apps.\r\n\r\nIf you are using MVP, this set of classes could help you a little bit. \r\n\r\n##Installation \r\n\r\nActually I don't have this library in **JCenter/Maven Central**, so if you want to use, follow this instructions to get everything work: \r\n\r\n**Gradle Installation**\r\n\r\n- Add it in your root build.gradle at the end of repositories:\r\n```gradle\r\nallprojects {\r\n\trepositories {\r\n\t\t...\r\n\t\tmaven { url \"https://jitpack.io\" }\r\n\t}\r\n}\r\n```\r\n\r\n- Add the dependency:\r\n```gradle\r\ndependencies {\r\n\t compile 'com.github.BlackBoxVision:mvp-helpers:v0.0.3'\r\n}\r\n```\r\n\r\n**Maven Installation**\r\n\r\n- Add this line to repositories section in pom.xml:\r\n```xml\r\n<repositories>\r\n\t<repository>\r\n\t   <id>jitpack.io</id>\r\n\t\t <url>https://jitpack.io</url>\r\n\t</repository>\r\n</repositories>\r\n```\r\n- Add the dependency:\r\n```xml\r\n<dependency>\r\n  <groupId>com.github.BlackBoxVision</groupId>\r\n  <artifactId>mvp-helpers</artifactId>\r\n\t<version>v0.0.3</version>\r\n</dependency>\r\n```\r\n\r\n**SBT Installation**\r\n\r\n- Add it in your build.sbt at the end of resolvers:\r\n```sbt\r\n  resolvers += \"jitpack\" at \"https://jitpack.io\"\r\n```\r\n\r\n- Add the dependency:\r\n```sbt\r\n  libraryDependencies += \"com.github.BlackBoxVision\" % \"mvp-helpers\" % \"v0.0.3\"\t\r\n```\r\n\r\n##Usage\r\n\r\nThe usage is really simple, the concepts behind this library are the following ones: \r\n\r\n- **View** → The **View** is an interface that contains methods related to UI interaction, to create you own you should extends the **BaseView** like in the following example: \r\n\r\n```java\r\npublic interface DetailsView extends BaseView {\r\n\r\n  void onInfoReceived(@NonNull Bundle information);\r\n  \r\n  void onInfoError(@NonNull String errorMessage);\r\n}\r\n```\r\n\r\n- **Interactor** → The **Interactor** is the class that do the hard work, all the blocking operations like **I/O, Networking, Database** Intectations should be done here. \r\n\r\nWhen you extend the **BaseInteractor** class, you get two useful methods **runOnBackground** and **runOnUiThread**. Both methods receives a **Runnable** as param. \r\n\r\n- **runOnBackground** is a method that executes the runnable you pass to it in an **Executor**. The executor is an instance generated by **Executors** class, it provides you with a fixed thread pool executor of 5 theads. Enough to do hard work. \r\n\r\n- **runOnUiThread** is a method that executes the runnable you pass to it in an **Handler**. The handler instance is generated with a reference to the **Main Looper**. In this way, we now that we really comunicate to the correct thread the updates to post, in our case, the UI one. \r\n\r\nCheck the following example: \r\n\r\n```java\r\n//This example uses Java 8 features, I assume the usage of retrolambda\r\npublic final class DetailsInteractor extends BaseInteractor {\r\n\r\n  public void retrieveDetailsFromService(@NonNull final String id, @NonNull final OnSuccessListener<Bundle> successListener, @NonNull final OnErrorListener<String> errorListener) {\r\n    runOnBackground(() -> {\r\n      //Getting data from somewhere\r\n      Bundle data = ... ;   \r\n      \r\n      if (data != null) {\r\n        runOnUiThread(() -> successListener.onSuccess(data));  \r\n      } else {\r\n        runOnUiThread(() -> errorListener.onError(\"Ups, something went wrong\"));\r\n      }\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n- **Presenter** → The **presenter** acts as a middle man between the **Interactor** and the **View**. When you request something to the presenter, he contacts the interactor object to get what he needs, and then he interacts with the view to make you get what you really need. Continue with the example of a Details: \r\n\r\n```java\r\n//I use method references from Java 8 to point the callbacks to interactor, I assume a working project with Retrolambda\r\npublic final class DetailsPresenter extends BasePresenter<DetailsView> {\r\n  private DetailsInteractor interactor;\r\n  \r\n  public DetailsPresenter() { \r\n    interactor = new DetailsInteractor();\r\n  }\r\n  \r\n  public void getInformationFromId(@NonNull String id) {\r\n    if (isViewAttached()) {\r\n      interactor.retrieveDetailsFromService(id, this::onSuccess, this::onError);\r\n    }\r\n  }\r\n  \r\n  private void onSuccess(@NonNull Bundle data) {\r\n    if (isViewAttached()) {\r\n      getView().onInfoReceived(data);\r\n    }\r\n  }\r\n  \r\n  private void onError(@NonNull String errorMessage) {\r\n    if (isViewAttached()) {\r\n      getView().onInfoError(errorMessage);\r\n    }\r\n  }\r\n}\r\n```\r\nAs you see, **BasePresenter** is a generic class, you have to pass to it the **View** that you want to use when you inherit from it. **BasePresenter** provides you with a set of methods to deal with **view** interfaces, that are the following ones: \r\n\r\n- **isViewAttached** → This method checks if you have set the view to the presenter, returns to you a boolean value that you should handle in your presenter implementation. \r\n\r\n- **detachView** → This method dereference the view, setting it to null. This method should be called in the onDestroy method in case of use in Activity, and onDestroyView in case of Fragment usage. \r\n\r\n- **registerView** → This method adds the view to the presenter, so you can start to handle the cicle of view - presenter - interactor interaction.\r\n\r\n- **getView** → simple getter, to make your access to the view defined more cleaner.\r\n\r\n##Complement with Android \r\n\r\nWell, that's the basics behind the library. At this point, you are asking yourself, how do I connect this classes with a Android??. Well, that's pretty simple! \r\n\r\nI work a lot with **Fragments**, they simplify a lot my work flow. I think in them as the **View** in Android. I let Activity manage Fragments, don't want to charge them, since they have a lot of responsabilities. \r\n\r\nTo finalize the explanation, check the sample implementation: \r\n\r\n```java\r\npublic final class DetailsFragment extends BaseFragment<DetailsPresenter> implements DetailsView {\r\n    @Override\r\n    public addPresenter() {\r\n      return new DetailsPresenter();\r\n    }\r\n    \r\n    @LayoutRes\r\n    @Override\r\n    public int getLayout() {\r\n      return R.layout.fragment_details;\r\n    }\r\n    \r\n    @Override\r\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        getPresenter.registerView(this);\r\n        getPresenter.getInformationFromId(\"ssdWRGD132\");\r\n    }\r\n    \r\n    @Override\r\n    void onInfoReceived(@NonNull Bundle information) {\r\n       Toast.makeText(getContext(), information.toString(), Toast.LENGTH_SHORT).show();\r\n    }\r\n    \r\n    @Override\r\n    void onInfoError(@NonNull String errorMessage) {\r\n       Toast.makeText(getContext(), errorMessage, Toast.LENGTH_SHORT).show();\r\n    }\r\n} \r\n```\r\n\r\nAs you see, this Fragment is a **generic** class that solves some troubles for you, **It has the ability to detach view for you in onDestroyView so you don't have to, auto inject views with butter knife, and lifecycle methods simplified**. \r\n\r\nWhen you inherit it, you will get the following methods to implement:\r\n\r\n- **addPresenter** → in this method you have to create you instance of Presenter. \r\n\r\n- **getLayout** → in this method you have pass the id reference to the layout. This library comes with **ButterKnife**, to provide efficiency I have implemented **onCreateView** in BaseFragment where I call **ButterKnife.bind** method, so you have view binding out of the box! :smile:\r\n\r\n- **getPresenter** → simple getter, to make your access to the presenter more cleaner.\r\n\r\n##Some notes on ButterKnife\r\n\r\nThe standard **ButterKnife** library is included by default. But there is a missing point, you have to add in your app **build.gradle** file the annotation procesor, if not, @Bind annotations won't work: \r\n\r\n```gradle\r\ndependencies {\r\n  annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'\r\n}\r\n```\r\n\r\n##Issues \r\n\r\nIf you found a bug, or you have an answer, or whatever. Please, open an [issue](https://github.com/BlackBoxVision/mvp-helpers/issues). I will do the best to fix it, or help you. \r\n\r\n##Contributing\r\n\r\nOf course, if you see something that you want to upgrade from this library, or a bug that needs to be solved, **PRs are welcome!**\r\n\r\n##License\r\n\r\nThis library is distributed under **MIT License**.\r\n\r\n>The MIT License (MIT)\r\n>Copyright (c) 2016 BlackBox Vision\r\n\r\n>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation >files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, >modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the >Software is furnished to do so, subject to the following conditions:\r\n\r\n>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the >Software.\r\n\r\n>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE >WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR >COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, >ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}